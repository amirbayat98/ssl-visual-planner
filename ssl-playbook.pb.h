// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ssl-playbook.proto

#ifndef PROTOBUF_ssl_2dplaybook_2eproto__INCLUDED
#define PROTOBUF_ssl_2dplaybook_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

class AgentInitPos;
class Target;
class Skill;
class Positions;
class Agents;
class BallInitPos;
class Tags;
class Plans;
class PlanBook;

// ===================================================================

class AgentInitPos : public ::google::protobuf::Message {
 public:
  AgentInitPos();
  virtual ~AgentInitPos();

  AgentInitPos(const AgentInitPos& from);

  inline AgentInitPos& operator=(const AgentInitPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentInitPos& default_instance();

  void Swap(AgentInitPos* other);

  // implements Message ----------------------------------------------

  AgentInitPos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentInitPos& from);
  void MergeFrom(const AgentInitPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // @@protoc_insertion_point(class_scope:AgentInitPos)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static AgentInitPos* default_instance_;
};
// -------------------------------------------------------------------

class Target : public ::google::protobuf::Message {
 public:
  Target();
  virtual ~Target();

  Target(const Target& from);

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Target& default_instance();

  void Swap(Target* other);

  // implements Message ----------------------------------------------

  Target* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Target& from);
  void MergeFrom(const Target& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline ::google::protobuf::int64 agent() const;
  inline void set_agent(::google::protobuf::int64 value);

  // required int64 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int64 index() const;
  inline void set_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Target)
 private:
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 agent_;
  ::google::protobuf::int64 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static Target* default_instance_;
};
// -------------------------------------------------------------------

class Skill : public ::google::protobuf::Message {
 public:
  Skill();
  virtual ~Skill();

  Skill(const Skill& from);

  inline Skill& operator=(const Skill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Skill& default_instance();

  void Swap(Skill* other);

  // implements Message ----------------------------------------------

  Skill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Skill& from);
  void MergeFrom(const Skill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline bool flag() const;
  inline void set_flag(bool value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int64 primary = 3;
  inline bool has_primary() const;
  inline void clear_primary();
  static const int kPrimaryFieldNumber = 3;
  inline ::google::protobuf::int64 primary() const;
  inline void set_primary(::google::protobuf::int64 value);

  // required int64 secondry = 4;
  inline bool has_secondry() const;
  inline void clear_secondry();
  static const int kSecondryFieldNumber = 4;
  inline ::google::protobuf::int64 secondry() const;
  inline void set_secondry(::google::protobuf::int64 value);

  // optional .Target target = 5;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 5;
  inline const ::Target& target() const;
  inline ::Target* mutable_target();
  inline ::Target* release_target();
  inline void set_allocated_target(::Target* target);

  // @@protoc_insertion_point(class_scope:Skill)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_primary();
  inline void clear_has_primary();
  inline void set_has_secondry();
  inline void clear_has_secondry();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int64 primary_;
  ::google::protobuf::int64 secondry_;
  ::Target* target_;
  bool flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static Skill* default_instance_;
};
// -------------------------------------------------------------------

class Positions : public ::google::protobuf::Message {
 public:
  Positions();
  virtual ~Positions();

  Positions(const Positions& from);

  inline Positions& operator=(const Positions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Positions& default_instance();

  void Swap(Positions* other);

  // implements Message ----------------------------------------------

  Positions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Positions& from);
  void MergeFrom(const Positions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float angle = 1;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 1;
  inline float angle() const;
  inline void set_angle(float value);

  // required double pos_x = 2;
  inline bool has_pos_x() const;
  inline void clear_pos_x();
  static const int kPosXFieldNumber = 2;
  inline double pos_x() const;
  inline void set_pos_x(double value);

  // required double pos_y = 3;
  inline bool has_pos_y() const;
  inline void clear_pos_y();
  static const int kPosYFieldNumber = 3;
  inline double pos_y() const;
  inline void set_pos_y(double value);

  // repeated .Skill skills = 4;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 4;
  inline const ::Skill& skills(int index) const;
  inline ::Skill* mutable_skills(int index);
  inline ::Skill* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::Skill >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::Skill >*
      mutable_skills();

  // required int64 tolerance = 6;
  inline bool has_tolerance() const;
  inline void clear_tolerance();
  static const int kToleranceFieldNumber = 6;
  inline ::google::protobuf::int64 tolerance() const;
  inline void set_tolerance(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Positions)
 private:
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_pos_x();
  inline void clear_has_pos_x();
  inline void set_has_pos_y();
  inline void clear_has_pos_y();
  inline void set_has_tolerance();
  inline void clear_has_tolerance();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double pos_x_;
  double pos_y_;
  ::google::protobuf::RepeatedPtrField< ::Skill > skills_;
  ::google::protobuf::int64 tolerance_;
  float angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static Positions* default_instance_;
};
// -------------------------------------------------------------------

class Agents : public ::google::protobuf::Message {
 public:
  Agents();
  virtual ~Agents();

  Agents(const Agents& from);

  inline Agents& operator=(const Agents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Agents& default_instance();

  void Swap(Agents* other);

  // implements Message ----------------------------------------------

  Agents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Agents& from);
  void MergeFrom(const Agents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // repeated .Positions p = 2;
  inline int p_size() const;
  inline void clear_p();
  static const int kPFieldNumber = 2;
  inline const ::Positions& p(int index) const;
  inline ::Positions* mutable_p(int index);
  inline ::Positions* add_p();
  inline const ::google::protobuf::RepeatedPtrField< ::Positions >&
      p() const;
  inline ::google::protobuf::RepeatedPtrField< ::Positions >*
      mutable_p();

  // @@protoc_insertion_point(class_scope:Agents)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::RepeatedPtrField< ::Positions > p_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static Agents* default_instance_;
};
// -------------------------------------------------------------------

class BallInitPos : public ::google::protobuf::Message {
 public:
  BallInitPos();
  virtual ~BallInitPos();

  BallInitPos(const BallInitPos& from);

  inline BallInitPos& operator=(const BallInitPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallInitPos& default_instance();

  void Swap(BallInitPos* other);

  // implements Message ----------------------------------------------

  BallInitPos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BallInitPos& from);
  void MergeFrom(const BallInitPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // @@protoc_insertion_point(class_scope:BallInitPos)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static BallInitPos* default_instance_;
};
// -------------------------------------------------------------------

class Tags : public ::google::protobuf::Message {
 public:
  Tags();
  virtual ~Tags();

  Tags(const Tags& from);

  inline Tags& operator=(const Tags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tags& default_instance();

  void Swap(Tags* other);

  // implements Message ----------------------------------------------

  Tags* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tags& from);
  void MergeFrom(const Tags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string s = 1;
  inline bool has_s() const;
  inline void clear_s();
  static const int kSFieldNumber = 1;
  inline const ::std::string& s() const;
  inline void set_s(const ::std::string& value);
  inline void set_s(const char* value);
  inline void set_s(const char* value, size_t size);
  inline ::std::string* mutable_s();
  inline ::std::string* release_s();
  inline void set_allocated_s(::std::string* s);

  // @@protoc_insertion_point(class_scope:Tags)
 private:
  inline void set_has_s();
  inline void clear_has_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* s_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static Tags* default_instance_;
};
// -------------------------------------------------------------------

class Plans : public ::google::protobuf::Message {
 public:
  Plans();
  virtual ~Plans();

  Plans(const Plans& from);

  inline Plans& operator=(const Plans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Plans& default_instance();

  void Swap(Plans* other);

  // implements Message ----------------------------------------------

  Plans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Plans& from);
  void MergeFrom(const Plans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AgentInitPos agentInitPos = 1;
  inline int agentinitpos_size() const;
  inline void clear_agentinitpos();
  static const int kAgentInitPosFieldNumber = 1;
  inline const ::AgentInitPos& agentinitpos(int index) const;
  inline ::AgentInitPos* mutable_agentinitpos(int index);
  inline ::AgentInitPos* add_agentinitpos();
  inline const ::google::protobuf::RepeatedPtrField< ::AgentInitPos >&
      agentinitpos() const;
  inline ::google::protobuf::RepeatedPtrField< ::AgentInitPos >*
      mutable_agentinitpos();

  // repeated .Agents agents = 2;
  inline int agents_size() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 2;
  inline const ::Agents& agents(int index) const;
  inline ::Agents* mutable_agents(int index);
  inline ::Agents* add_agents();
  inline const ::google::protobuf::RepeatedPtrField< ::Agents >&
      agents() const;
  inline ::google::protobuf::RepeatedPtrField< ::Agents >*
      mutable_agents();

  // required .BallInitPos bip = 3;
  inline bool has_bip() const;
  inline void clear_bip();
  static const int kBipFieldNumber = 3;
  inline const ::BallInitPos& bip() const;
  inline ::BallInitPos* mutable_bip();
  inline ::BallInitPos* release_bip();
  inline void set_allocated_bip(::BallInitPos* bip);

  // required float chance = 4;
  inline bool has_chance() const;
  inline void clear_chance();
  static const int kChanceFieldNumber = 4;
  inline float chance() const;
  inline void set_chance(float value);

  // required float lastdist = 5;
  inline bool has_lastdist() const;
  inline void clear_lastdist();
  static const int kLastdistFieldNumber = 5;
  inline float lastdist() const;
  inline void set_lastdist(float value);

  // required string planMode = 6;
  inline bool has_planmode() const;
  inline void clear_planmode();
  static const int kPlanModeFieldNumber = 6;
  inline const ::std::string& planmode() const;
  inline void set_planmode(const ::std::string& value);
  inline void set_planmode(const char* value);
  inline void set_planmode(const char* value, size_t size);
  inline ::std::string* mutable_planmode();
  inline ::std::string* release_planmode();
  inline void set_allocated_planmode(::std::string* planmode);

  // repeated .Tags tags = 7;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 7;
  inline const ::Tags& tags(int index) const;
  inline ::Tags* mutable_tags(int index);
  inline ::Tags* add_tags();
  inline const ::google::protobuf::RepeatedPtrField< ::Tags >&
      tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::Tags >*
      mutable_tags();

  // @@protoc_insertion_point(class_scope:Plans)
 private:
  inline void set_has_bip();
  inline void clear_has_bip();
  inline void set_has_chance();
  inline void clear_has_chance();
  inline void set_has_lastdist();
  inline void clear_has_lastdist();
  inline void set_has_planmode();
  inline void clear_has_planmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AgentInitPos > agentinitpos_;
  ::google::protobuf::RepeatedPtrField< ::Agents > agents_;
  ::BallInitPos* bip_;
  float chance_;
  float lastdist_;
  ::std::string* planmode_;
  ::google::protobuf::RepeatedPtrField< ::Tags > tags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static Plans* default_instance_;
};
// -------------------------------------------------------------------

class PlanBook : public ::google::protobuf::Message {
 public:
  PlanBook();
  virtual ~PlanBook();

  PlanBook(const PlanBook& from);

  inline PlanBook& operator=(const PlanBook& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanBook& default_instance();

  void Swap(PlanBook* other);

  // implements Message ----------------------------------------------

  PlanBook* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlanBook& from);
  void MergeFrom(const PlanBook& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Plans plans = 1;
  inline int plans_size() const;
  inline void clear_plans();
  static const int kPlansFieldNumber = 1;
  inline const ::Plans& plans(int index) const;
  inline ::Plans* mutable_plans(int index);
  inline ::Plans* add_plans();
  inline const ::google::protobuf::RepeatedPtrField< ::Plans >&
      plans() const;
  inline ::google::protobuf::RepeatedPtrField< ::Plans >*
      mutable_plans();

  // required float apiversion = 2;
  inline bool has_apiversion() const;
  inline void clear_apiversion();
  static const int kApiversionFieldNumber = 2;
  inline float apiversion() const;
  inline void set_apiversion(float value);

  // required int64 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlanBook)
 private:
  inline void set_has_apiversion();
  inline void clear_has_apiversion();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Plans > plans_;
  ::google::protobuf::int64 id_;
  float apiversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_AssignDesc_ssl_2dplaybook_2eproto();
  friend void protobuf_ShutdownFile_ssl_2dplaybook_2eproto();

  void InitAsDefaultInstance();
  static PlanBook* default_instance_;
};
// ===================================================================


// ===================================================================

// AgentInitPos

// required double x = 1;
inline bool AgentInitPos::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentInitPos::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentInitPos::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentInitPos::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double AgentInitPos::x() const {
  return x_;
}
inline void AgentInitPos::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool AgentInitPos::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentInitPos::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentInitPos::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentInitPos::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double AgentInitPos::y() const {
  return y_;
}
inline void AgentInitPos::set_y(double value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Target

// required int64 agent = 1;
inline bool Target::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Target::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Target::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Target::clear_agent() {
  agent_ = GOOGLE_LONGLONG(0);
  clear_has_agent();
}
inline ::google::protobuf::int64 Target::agent() const {
  return agent_;
}
inline void Target::set_agent(::google::protobuf::int64 value) {
  set_has_agent();
  agent_ = value;
}

// required int64 index = 2;
inline bool Target::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Target::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Target::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Target::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::int64 Target::index() const {
  return index_;
}
inline void Target::set_index(::google::protobuf::int64 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// Skill

// required bool flag = 1;
inline bool Skill::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Skill::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Skill::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Skill::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool Skill::flag() const {
  return flag_;
}
inline void Skill::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
}

// required string name = 2;
inline bool Skill::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Skill::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Skill::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Skill::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Skill::name() const {
  return *name_;
}
inline void Skill::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Skill::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Skill::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Skill::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Skill::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Skill::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 primary = 3;
inline bool Skill::has_primary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Skill::set_has_primary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Skill::clear_has_primary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Skill::clear_primary() {
  primary_ = GOOGLE_LONGLONG(0);
  clear_has_primary();
}
inline ::google::protobuf::int64 Skill::primary() const {
  return primary_;
}
inline void Skill::set_primary(::google::protobuf::int64 value) {
  set_has_primary();
  primary_ = value;
}

// required int64 secondry = 4;
inline bool Skill::has_secondry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Skill::set_has_secondry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Skill::clear_has_secondry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Skill::clear_secondry() {
  secondry_ = GOOGLE_LONGLONG(0);
  clear_has_secondry();
}
inline ::google::protobuf::int64 Skill::secondry() const {
  return secondry_;
}
inline void Skill::set_secondry(::google::protobuf::int64 value) {
  set_has_secondry();
  secondry_ = value;
}

// optional .Target target = 5;
inline bool Skill::has_target() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Skill::set_has_target() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Skill::clear_has_target() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Skill::clear_target() {
  if (target_ != NULL) target_->::Target::Clear();
  clear_has_target();
}
inline const ::Target& Skill::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::Target* Skill::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::Target;
  return target_;
}
inline ::Target* Skill::release_target() {
  clear_has_target();
  ::Target* temp = target_;
  target_ = NULL;
  return temp;
}
inline void Skill::set_allocated_target(::Target* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// -------------------------------------------------------------------

// Positions

// required float angle = 1;
inline bool Positions::has_angle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Positions::set_has_angle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Positions::clear_has_angle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Positions::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float Positions::angle() const {
  return angle_;
}
inline void Positions::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// required double pos_x = 2;
inline bool Positions::has_pos_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Positions::set_has_pos_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Positions::clear_has_pos_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Positions::clear_pos_x() {
  pos_x_ = 0;
  clear_has_pos_x();
}
inline double Positions::pos_x() const {
  return pos_x_;
}
inline void Positions::set_pos_x(double value) {
  set_has_pos_x();
  pos_x_ = value;
}

// required double pos_y = 3;
inline bool Positions::has_pos_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Positions::set_has_pos_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Positions::clear_has_pos_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Positions::clear_pos_y() {
  pos_y_ = 0;
  clear_has_pos_y();
}
inline double Positions::pos_y() const {
  return pos_y_;
}
inline void Positions::set_pos_y(double value) {
  set_has_pos_y();
  pos_y_ = value;
}

// repeated .Skill skills = 4;
inline int Positions::skills_size() const {
  return skills_.size();
}
inline void Positions::clear_skills() {
  skills_.Clear();
}
inline const ::Skill& Positions::skills(int index) const {
  return skills_.Get(index);
}
inline ::Skill* Positions::mutable_skills(int index) {
  return skills_.Mutable(index);
}
inline ::Skill* Positions::add_skills() {
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Skill >&
Positions::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::Skill >*
Positions::mutable_skills() {
  return &skills_;
}

// required int64 tolerance = 6;
inline bool Positions::has_tolerance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Positions::set_has_tolerance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Positions::clear_has_tolerance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Positions::clear_tolerance() {
  tolerance_ = GOOGLE_LONGLONG(0);
  clear_has_tolerance();
}
inline ::google::protobuf::int64 Positions::tolerance() const {
  return tolerance_;
}
inline void Positions::set_tolerance(::google::protobuf::int64 value) {
  set_has_tolerance();
  tolerance_ = value;
}

// -------------------------------------------------------------------

// Agents

// required uint64 id = 1;
inline bool Agents::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Agents::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Agents::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Agents::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 Agents::id() const {
  return id_;
}
inline void Agents::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// repeated .Positions p = 2;
inline int Agents::p_size() const {
  return p_.size();
}
inline void Agents::clear_p() {
  p_.Clear();
}
inline const ::Positions& Agents::p(int index) const {
  return p_.Get(index);
}
inline ::Positions* Agents::mutable_p(int index) {
  return p_.Mutable(index);
}
inline ::Positions* Agents::add_p() {
  return p_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Positions >&
Agents::p() const {
  return p_;
}
inline ::google::protobuf::RepeatedPtrField< ::Positions >*
Agents::mutable_p() {
  return &p_;
}

// -------------------------------------------------------------------

// BallInitPos

// required double x = 1;
inline bool BallInitPos::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BallInitPos::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BallInitPos::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BallInitPos::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double BallInitPos::x() const {
  return x_;
}
inline void BallInitPos::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool BallInitPos::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BallInitPos::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BallInitPos::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BallInitPos::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double BallInitPos::y() const {
  return y_;
}
inline void BallInitPos::set_y(double value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Tags

// required string s = 1;
inline bool Tags::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tags::set_has_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tags::clear_has_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tags::clear_s() {
  if (s_ != &::google::protobuf::internal::kEmptyString) {
    s_->clear();
  }
  clear_has_s();
}
inline const ::std::string& Tags::s() const {
  return *s_;
}
inline void Tags::set_s(const ::std::string& value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void Tags::set_s(const char* value) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(value);
}
inline void Tags::set_s(const char* value, size_t size) {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  s_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tags::mutable_s() {
  set_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    s_ = new ::std::string;
  }
  return s_;
}
inline ::std::string* Tags::release_s() {
  clear_has_s();
  if (s_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = s_;
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Tags::set_allocated_s(::std::string* s) {
  if (s_ != &::google::protobuf::internal::kEmptyString) {
    delete s_;
  }
  if (s) {
    set_has_s();
    s_ = s;
  } else {
    clear_has_s();
    s_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Plans

// repeated .AgentInitPos agentInitPos = 1;
inline int Plans::agentinitpos_size() const {
  return agentinitpos_.size();
}
inline void Plans::clear_agentinitpos() {
  agentinitpos_.Clear();
}
inline const ::AgentInitPos& Plans::agentinitpos(int index) const {
  return agentinitpos_.Get(index);
}
inline ::AgentInitPos* Plans::mutable_agentinitpos(int index) {
  return agentinitpos_.Mutable(index);
}
inline ::AgentInitPos* Plans::add_agentinitpos() {
  return agentinitpos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AgentInitPos >&
Plans::agentinitpos() const {
  return agentinitpos_;
}
inline ::google::protobuf::RepeatedPtrField< ::AgentInitPos >*
Plans::mutable_agentinitpos() {
  return &agentinitpos_;
}

// repeated .Agents agents = 2;
inline int Plans::agents_size() const {
  return agents_.size();
}
inline void Plans::clear_agents() {
  agents_.Clear();
}
inline const ::Agents& Plans::agents(int index) const {
  return agents_.Get(index);
}
inline ::Agents* Plans::mutable_agents(int index) {
  return agents_.Mutable(index);
}
inline ::Agents* Plans::add_agents() {
  return agents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Agents >&
Plans::agents() const {
  return agents_;
}
inline ::google::protobuf::RepeatedPtrField< ::Agents >*
Plans::mutable_agents() {
  return &agents_;
}

// required .BallInitPos bip = 3;
inline bool Plans::has_bip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Plans::set_has_bip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Plans::clear_has_bip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Plans::clear_bip() {
  if (bip_ != NULL) bip_->::BallInitPos::Clear();
  clear_has_bip();
}
inline const ::BallInitPos& Plans::bip() const {
  return bip_ != NULL ? *bip_ : *default_instance_->bip_;
}
inline ::BallInitPos* Plans::mutable_bip() {
  set_has_bip();
  if (bip_ == NULL) bip_ = new ::BallInitPos;
  return bip_;
}
inline ::BallInitPos* Plans::release_bip() {
  clear_has_bip();
  ::BallInitPos* temp = bip_;
  bip_ = NULL;
  return temp;
}
inline void Plans::set_allocated_bip(::BallInitPos* bip) {
  delete bip_;
  bip_ = bip;
  if (bip) {
    set_has_bip();
  } else {
    clear_has_bip();
  }
}

// required float chance = 4;
inline bool Plans::has_chance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Plans::set_has_chance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Plans::clear_has_chance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Plans::clear_chance() {
  chance_ = 0;
  clear_has_chance();
}
inline float Plans::chance() const {
  return chance_;
}
inline void Plans::set_chance(float value) {
  set_has_chance();
  chance_ = value;
}

// required float lastdist = 5;
inline bool Plans::has_lastdist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Plans::set_has_lastdist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Plans::clear_has_lastdist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Plans::clear_lastdist() {
  lastdist_ = 0;
  clear_has_lastdist();
}
inline float Plans::lastdist() const {
  return lastdist_;
}
inline void Plans::set_lastdist(float value) {
  set_has_lastdist();
  lastdist_ = value;
}

// required string planMode = 6;
inline bool Plans::has_planmode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Plans::set_has_planmode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Plans::clear_has_planmode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Plans::clear_planmode() {
  if (planmode_ != &::google::protobuf::internal::kEmptyString) {
    planmode_->clear();
  }
  clear_has_planmode();
}
inline const ::std::string& Plans::planmode() const {
  return *planmode_;
}
inline void Plans::set_planmode(const ::std::string& value) {
  set_has_planmode();
  if (planmode_ == &::google::protobuf::internal::kEmptyString) {
    planmode_ = new ::std::string;
  }
  planmode_->assign(value);
}
inline void Plans::set_planmode(const char* value) {
  set_has_planmode();
  if (planmode_ == &::google::protobuf::internal::kEmptyString) {
    planmode_ = new ::std::string;
  }
  planmode_->assign(value);
}
inline void Plans::set_planmode(const char* value, size_t size) {
  set_has_planmode();
  if (planmode_ == &::google::protobuf::internal::kEmptyString) {
    planmode_ = new ::std::string;
  }
  planmode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Plans::mutable_planmode() {
  set_has_planmode();
  if (planmode_ == &::google::protobuf::internal::kEmptyString) {
    planmode_ = new ::std::string;
  }
  return planmode_;
}
inline ::std::string* Plans::release_planmode() {
  clear_has_planmode();
  if (planmode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = planmode_;
    planmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Plans::set_allocated_planmode(::std::string* planmode) {
  if (planmode_ != &::google::protobuf::internal::kEmptyString) {
    delete planmode_;
  }
  if (planmode) {
    set_has_planmode();
    planmode_ = planmode;
  } else {
    clear_has_planmode();
    planmode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Tags tags = 7;
inline int Plans::tags_size() const {
  return tags_.size();
}
inline void Plans::clear_tags() {
  tags_.Clear();
}
inline const ::Tags& Plans::tags(int index) const {
  return tags_.Get(index);
}
inline ::Tags* Plans::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline ::Tags* Plans::add_tags() {
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Tags >&
Plans::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::Tags >*
Plans::mutable_tags() {
  return &tags_;
}

// -------------------------------------------------------------------

// PlanBook

// repeated .Plans plans = 1;
inline int PlanBook::plans_size() const {
  return plans_.size();
}
inline void PlanBook::clear_plans() {
  plans_.Clear();
}
inline const ::Plans& PlanBook::plans(int index) const {
  return plans_.Get(index);
}
inline ::Plans* PlanBook::mutable_plans(int index) {
  return plans_.Mutable(index);
}
inline ::Plans* PlanBook::add_plans() {
  return plans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Plans >&
PlanBook::plans() const {
  return plans_;
}
inline ::google::protobuf::RepeatedPtrField< ::Plans >*
PlanBook::mutable_plans() {
  return &plans_;
}

// required float apiversion = 2;
inline bool PlanBook::has_apiversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanBook::set_has_apiversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanBook::clear_has_apiversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanBook::clear_apiversion() {
  apiversion_ = 0;
  clear_has_apiversion();
}
inline float PlanBook::apiversion() const {
  return apiversion_;
}
inline void PlanBook::set_apiversion(float value) {
  set_has_apiversion();
  apiversion_ = value;
}

// required int64 id = 3;
inline bool PlanBook::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanBook::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanBook::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanBook::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 PlanBook::id() const {
  return id_;
}
inline void PlanBook::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ssl_2dplaybook_2eproto__INCLUDED
